<template>
  <div 
    class="dashboard-table-element"
    :class="{ 
      'lock': elementInfo.lock, 
      'invisible': elementInfo.isInvisible && elementInfo.isTemplatePlaceholder 
    }"
    :data-element-id="elementInfo.id"
    :style="{
      width: elementInfo.width + 'px',
      height: elementInfo.height + 'px',
      left: elementInfo.left + 'px',
      top: elementInfo.top + 'px',
    }"
  >
    <div
      class="rotate-wrapper"
      :style="{ transform: `rotate(${elementInfo.rotate}deg)` }"
    >
      <div 
        class="element-content"
        ref="elementRef"
        :style="{
          width: elementInfo.width + 'px',
          height: elementInfo.height + 'px',
        }"
        v-contextmenu="contextmenus"
        @mousedown="$event => handleSelectElement($event)"
        @touchstart="$event => handleSelectElement($event)"
      >
        <ElementOutline
          :width="elementInfo.width"
          :height="elementInfo.height"
          :outline="elementInfo.outline"
        />
        <!-- Use real DashboardTable if element has real data, otherwise use mock -->
        <DashboardTable 
          v-if="!elementInfo.isTemplatePlaceholder && elementInfo.selectedFilters" 
          overflow="auto"
          :container-width="elementInfo.width"
          :container-height="elementInfo.height"
          :attritional-only="elementInfo.attritionalOnly"
          :large-only="elementInfo.largeOnly"
          :weather-only="elementInfo.weatherOnly"
          :total-ultimate-only="elementInfo.totalUltimateOnly"
        />
        <MockDashboardTable v-else />
        
        <!-- Drag handlers to ensure the element can be selected -->
        <div class="drag-handler top"></div>
        <div class="drag-handler bottom"></div>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted } from 'vue'
import { type PPTElement } from '@/types/slides'
import type { ContextmenuItem } from '@/components/Contextmenu/types'
import DashboardTable from '@/components/DashboardTable/DashboardTable.vue'
import MockDashboardTable from '@/components/DashboardTable/MockDashboardTable.vue'
import ElementOutline from '@/views/components/element/ElementOutline.vue'
import { useDashboardStore } from '@/store/dashboard'
import { portfolioService } from '@/services/portfolioService'

const props = defineProps<{
  elementInfo: PPTElement & {
    width: number
    height: number
    rotate: number
    outline?: any
    props?: any
    // Dashboard table specific properties
    portfolioId?: string
    portfolioName?: string
    bounceId?: string
    bounceName?: string
    selectedFilters?: any
    accidentUnderwriting?: 'uw' | 'acc'
    columnConfig?: any
    isTemplatePlaceholder?: boolean
    isInvisible?: boolean
    attritionalOnly?: boolean
    largeOnly?: boolean
    weatherOnly?: boolean
    totalUltimateOnly?: boolean
  }
  selectElement: (e: MouseEvent | TouchEvent, element: PPTElement, canMove?: boolean) => void
  contextmenus: () => ContextmenuItem[] | null
}>()

const elementRef = ref<HTMLElement>()
const dashboardStore = useDashboardStore()

// Load portfolio data if element has portfolio/bounce info
onMounted(async () => {
  if (props.elementInfo.portfolioId && props.elementInfo.bounceId && !props.elementInfo.isTemplatePlaceholder) {
    try {      
      // Fetch complete portfolio data
      const completeData = await portfolioService.fetchCompletePortfolioData(
        props.elementInfo.portfolioId,
        props.elementInfo.bounceId
      )
      
      // Parse bounce name
      const bounceName = props.elementInfo.bounceName || ''
      completeData.portfolioName = props.elementInfo.portfolioName || ''
      completeData.bounceName = bounceName.slice(26) || bounceName.slice(25)
      completeData.bounceDate = bounceName.slice(0, 6)
      completeData.bounceFullName = bounceName
      
      // Set portfolio data in dashboard store
      dashboardStore.setPortfolioData(completeData)
      
      // Wait for portfolio data to be fully processed
      await new Promise(resolve => setTimeout(resolve, 200))
      
      // Apply stored filters
      if (props.elementInfo.selectedFilters) {
        Object.assign(dashboardStore.selectedFilters, props.elementInfo.selectedFilters)
      }
      
      if (props.elementInfo.accidentUnderwriting) {
        dashboardStore.setAccidentUnderwriting(props.elementInfo.accidentUnderwriting)
      }
      
      if (props.elementInfo.columnConfig?.showColumn) {
        dashboardStore.setColumnState({
          showColumn: props.elementInfo.columnConfig.showColumn,
          margin: props.elementInfo.columnConfig.margin,
          showColumnTotal: props.elementInfo.columnConfig.showColumnTotal,
          totalMargin: props.elementInfo.columnConfig.totalMargin
        })
      }
      
      await dashboardStore.loadDashboard(completeData)
      
    } catch (error) {
      console.error('❌ Error loading portfolio data for dashboard table:', error)
    }
  }
})

const handleSelectElement = (e: MouseEvent | TouchEvent, canMove = true) => {
  if (props.elementInfo.lock) return
  e.stopPropagation()

  props.selectElement(e, props.elementInfo, canMove)
}
</script>

<style scoped>
.dashboard-table-element {
  position: absolute;
  cursor: pointer;
  user-select: none;
}

.rotate-wrapper {
  width: 100%;
  height: 100%;
}

.element-content {
  position: relative;
  width: 100%;
  height: 100%;
}

.drag-handler {
  position: absolute;
  left: 0;
  right: 0;
  height: 10px;
  z-index: 1;
}

.drag-handler.top {
  top: 0;
}

.drag-handler.bottom {
  bottom: 0;
}

.lock {
  cursor: not-allowed;
}

.invisible {
  opacity: 0;
  pointer-events: auto; /* Keep clickable for portfolio data functionality */
}
</style>
